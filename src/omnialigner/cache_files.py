# Files defined in this file, are used to load data from cache
# If the cache files are not existing, they will be generated by the pipeline

import os
from enum import Enum, auto
from typing import Dict
import json

import pandas as pd

from omnialigner.logging import logger as logging
from omnialigner.dtypes import DataType


class ProjInfo(object):
    def __init__(self, config_datasets: Dict):
        self.config_datasets = config_datasets
        self.project = config_datasets["project"]
        self.group = config_datasets["group"]
        self.version = config_datasets["version"]
        self.root_dir = os.path.expanduser(config_datasets["root_dir"])
        self.method = config_datasets["method"]
        self.tag = config_datasets["tag"]
        self.raw_img_prefix = config_datasets["raw_img_prefix"]
        self.dict_IHC_layer = self.load_IHC_info()
        self._load_project_info(config_datasets["file_data"])

    def __call__(self, **kwargs):
        return self.__dict__

    def _load_project_info(self, file_data):
        df_project = pd.read_csv(file_data, dtype={
            "project": str, 
            "group": str, 
            "sample": str, 
            "group_idx": int,
            "type": str
        }, index_col=0)
        self.df_proj_info = df_project[
            (df_project["project"] == self.project) & 
            (df_project["group"] == self.group)
        ]


    def __len__(self) -> int:
        return len(self.df_proj_info)

    def get_sample_name(self, i_layer: int) -> str:
        df_line = self.df_proj_info[
            (self.df_proj_info["group_idx"] == i_layer)
        ].iloc[0]
        sample = df_line["sample"]
        return sample

    def get_dtype(self, i_layer: int) -> str:
        df_line = self.df_proj_info[
            (self.df_proj_info["group_idx"] == i_layer)
        ].iloc[0]
        dtype = df_line["type"]
        return dtype

    def load_IHC_info(self) -> Dict[str, str]:
        if "file_IHC_name" not in self.config_datasets:
            return {}

        file_ihc = os.path.expanduser(self.config_datasets["file_IHC_name"])
        with open(file_ihc, "r", encoding="utf-8") as f:
            dict_IHC_layer = json.load(f)

        return dict_IHC_layer


class ComparableEnum(Enum):
    def __lt__(self, other):
        if isinstance(other, ComparableEnum):
            return self.value < other.value
        return NotImplemented

    def __le__(self, other):
        if isinstance(other, ComparableEnum):
            return self.value <= other.value
        return NotImplemented

    def __gt__(self, other):
        if isinstance(other, ComparableEnum):
            return self.value > other.value
        return NotImplemented

    def __ge__(self, other):
        if isinstance(other, ComparableEnum):
            return self.value >= other.value
        return NotImplemented

class StageBase(ComparableEnum):
    def load_projInfo(self, projInfo: ProjInfo, check_exist: bool=True):
        projInfo = projInfo
        check_exist = check_exist

    def __str__(self):
        return self.name

    def add_dir_to_name(self, out_dir: str, dict_file_prefix: Dict[str, str]):
        for key, value in dict_file_prefix.items():
            dict_file_prefix[key] = f"{out_dir}/{value}"
        return dict_file_prefix

    def is_file_all_exist(self, dict_file_name: Dict[str, str]):
        for file_name in dict_file_name.values():
            if not os.path.exists(file_name):
                logging.warning(f"{file_name} not found for stage: {self.name}. Return None")
                return False
        return True

    def __call__(self, *args, **kwargs)->Dict[str, str]:
        raise NotImplementedError

    
class StageTag(StageBase):
    DATA = auto()
    RAW = auto()
    PAD = auto()
    STACK = auto()
    AFFINE = auto()
    NONRIGID = auto()
    NONRIGID_TILES = auto()

    def get_file_name(self, projInfo: ProjInfo, check_exist: bool=True) -> Dict[str, str]:
        tag_to_config = {
            "DATA": {
                "dir_prefix": "",
                "dict_file_prefix": {}
            },
            "RAW": {
                "dir_prefix": "01.ome_tiff",
                "dict_file_prefix": {}
            },
            "PAD": {
                "dir_prefix": "04.detect_kpts",
                "dict_file_prefix": {
                    "padded_tensor": "merged_tensor.pt",
                    "merged_padded_sizes": "merged_padded_sizes.pt",
                    "l_ratio": "l_ratio.pt"
                }
            },
            "STACK": {
                "dir_prefix": "04.detect_kpts",
                "dict_file_prefix": {
                    "padded_tensor": "merged_tensor.flip_angles.pt",
                    "l_kpts_pairs": "l_kpts_pairs.flip_angles.pt",
                    "flip_angle": "flip_angle.pt"
                }
            },
            "AFFINE": {
                "dir_prefix": "05.align3d",
                "dict_file_prefix": {
                    "padded_tensor": "affine_tensor.pt",
                    "affine_kpts": "affine_kpts.pt",
                    "affine_model": "affine_model.pt",
                    "out_dir": ""
                }
            },
            "NONRIGID": {
                "dir_prefix": "05.align3d",
                "dict_file_prefix": {
                    "padded_tensor": "nonrigid_tensor.pt",
                    "nonrigid_kpts": "nonrigid_kpts.pt",
                    "nonrigid_model": "nonrigid_model.pt",
                    "out_dir": ""
                }
            },
            "NONRIGID_TILES": {
                "dir_prefix": "06.nonrigid_tiles",
                "dict_file_prefix": {
                    "disp": "nonrigid_disp.pt",
                    "out_dir": ""
                }
            },
        }

        default_config = {
            "dir_prefix": "05.align3d",
            "dict_file_prefix": {
                "padded_tensor": "aligned_tensor.final.pt",
                "nonrigid_model": "nonrigid_model.pt",
                "out_dir": ""
            }
        }

        config = tag_to_config.get(self.name, default_config)
        dir_prefix = config["dir_prefix"]
        dict_file_prefix = config["dict_file_prefix"]

        out_dir = f"{projInfo.root_dir}/analysis/{projInfo.project}/{projInfo.version}/{dir_prefix}/{projInfo.group}/"
        data_dir = f"{projInfo.root_dir}/data/{projInfo.group}/{dir_prefix}/{projInfo.group}"
        
        if self.name != "DATA":
            os.makedirs(out_dir, exist_ok=True)
        
        dict_file_prefix = self.add_dir_to_name(out_dir, dict_file_prefix)
        if not check_exist:
            return dict_file_prefix

        if self.is_file_all_exist(dict_file_prefix):
            return dict_file_prefix
        
        return None

class StageSampleTag(StageBase):
    DATA = auto()
    RAW = auto()
    KEYPOINTS = auto()
    EMBED = auto()
    EMBED_NONRIGID = auto()
    H5AD = auto()
    AFFINE_HD = auto()
    NONRIGID_HD = auto()
    MASK = auto()
    NONRIGID_TILES_HD = auto()
    TRIDENT_DATA = auto()
    ZS_DATA = auto()

    def get_file_name(self, i_layer: int, projInfo: ProjInfo, check_exist: bool=True) -> Dict[str, str]:
        sample_name = projInfo.get_sample_name(i_layer)
        dtype = projInfo.get_dtype(i_layer)
        tag_to_config = {
            "DATA": {
                "dir_prefix": "",
                "dict_file_prefix": {"data": f"{sample_name}{projInfo.raw_img_prefix}"}
            },
            "RAW": {
                "dir_prefix": "01.ome_tiff",
                "dict_file_prefix": {
                    "dir": "",
                    "raw": f"{sample_name}.ome.tiff",
                }
            },
            "EMBED": {
                "dir_prefix": "02.1.dino_feats",
                "dict_file_prefix": {"embed": f"{sample_name}_{projInfo.method}.pt"}
            },
            "EMBED_NONRIGID": {
                "dir_prefix": "03.dino_nonrigid_feats",
                "dict_file_prefix": {"embed_nonrigid": f"{sample_name}_{projInfo.method}.nonrigid.zarr"}
            },
            "KEYPOINTS": {
                "dir_prefix": "04.detect_kpts",
                "dict_file_prefix": {"kpts": f"{i_layer}.kpts.pth"}
            },
            "H5AD": {
                "dir_prefix": "06.fetch_data",
                "dict_file_prefix": {"h5ad": f"{sample_name}_{projInfo.method}.h5ad"}
            },
            "AFFINE_HD": {
                "dir_prefix": "07.fetch_raw",
                "dict_file_prefix": {"zarr": f"{i_layer}_zoom0.zarr" if projInfo.tag == DataType.RAW else f"{i_layer}.{projInfo.tag}.zarr"}
            },
            "NONRIGID_HD": {
                "dir_prefix": "07.fetch_raw",
                "dict_file_prefix": {"zarr": f"{i_layer}_zoom0.nonrigid.zarr"  if projInfo.tag == DataType.RAW else f"{i_layer}.nonrigid.{projInfo.tag}.zarr"}
            },
            "MASK": {
                "dir_prefix": "02.1.dino_feats",
                "dict_file_prefix": {"mask": f"h5ad/{i_layer}.npy"}
            },
            "NONRIGID_TILES_HD": {
                "dir_prefix": "07.fetch_raw",
                "dict_file_prefix": {"zarr": f"{sample_name}.nonrigid_tiles.{projInfo.tag}.zarr"}
            },
            "TRIDENT_DATA": {
                "dir_prefix": "trident_processed",
                "dict_file_prefix": {
                    "cls": f"20x_256px_0px_overlap/features_conch_v15/{sample_name}.h5",
                    "sub": f"20x_256px_0px_overlap/attention_features_conch_v15/{sample_name}_flatten.h5",
                    "dir": ""
                }
            },
            "ZS_DATA": {
                "dir_prefix": "lazy_slide",
                "dict_file_prefix": {
                    "zarr": f"{sample_name}_cellseg_plip.zarr"
                }
            },

        }

        config = tag_to_config.get(self.name, {
            "dir_prefix": "11.spatial_data",
            "dict_file_prefix": {"zarr": f"sub_{dtype}_{i_layer}.zarr"}
        })

        dir_prefix = config["dir_prefix"]
        dict_file_prefix = config["dict_file_prefix"]
        data_dir = f"{projInfo.root_dir}/data/{projInfo.project}/{dir_prefix}/{projInfo.group}"
        analysis_dir = f"{projInfo.root_dir}/analysis/{projInfo.project}/{projInfo.version}/{dir_prefix}/{projInfo.group}/"
        out_dir = data_dir if self.name == "DATA" else analysis_dir
        if len(dir_prefix) > 0:
            os.makedirs(out_dir, exist_ok=True)
        
        dict_file_prefix = self.add_dir_to_name(out_dir, dict_file_prefix)
        if not check_exist:
            return dict_file_prefix

        if self.is_file_all_exist(dict_file_prefix):
            return dict_file_prefix
        
        return None



